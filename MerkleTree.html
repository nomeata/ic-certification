<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Dyadic.html">Dyadic</a></li></li><li><li><a href="MerkleTree.html">MerkleTree</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Key">Key</a></li></li><li><li><a href="#type.Value">Value</a></li></li><li><li><a href="#type.Tree">Tree</a></li></li><li><li><a href="#type.Witness">Witness</a></li></li><li><li><a href="#type.Hash">Hash</a></li></li><li><li><a href="#treeHash">treeHash</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#reveal">reveal</a></li></li><li><li><a href="#merge">merge</a></li></li><li><li><a href="#revealNothing">revealNothing</a></li></li><li><li><a href="#reveals">reveals</a></li></li><li><li><a href="#witnessUnderLabel">witnessUnderLabel</a></li></li><li><li><a href="#hashUnderLabel">hashUnderLabel</a></li></li></ul></nav><div class="documentation"><h1>MerkleTree</h1><p><strong>A merkle tree</strong></p>
<p>This library provides a simple merkle tree data structure for Motoko.
It provides a key-value store, where both keys and values are of type Blob.</p>
<pre class="motoko"><code class="motoko">var t = MerkleTree.empty();
t := MerkleTree.put(t, &quot;Alice&quot;, &quot;\00\01&quot;);
t := MerkleTree.put(t, &quot;Bob&quot;, &quot;\00\02&quot;);

let w = MerkleTree.reveals(t, [&quot;Alice&quot; : Blob, &quot;Malfoy&quot;: Blob].vals());</code></pre><p>will produce</p>
<pre><code>#fork (#labeled (&quot;\3B…\43&quot;, #leaf(&quot;\00\01&quot;)), #pruned (&quot;\EB…\87&quot;))</code></pre>

<p>The witness format is compatible with
the <a href="https://sdk.dfinity.org/docs/interface-spec/index.html#_certificate">HashTree</a> used by the Internet Computer,
so client-side, the same logic can be used, but note</p>
<ul><li>the trees produces here are flat; no nested subtrees</li><li>keys need to be SHA256-hashed before they are looked up in the witness</li><li>no CBOR encoding is provided here. The assumption is that the witnesses are transferred
 via Candid, and decoded to a data type understood by the client-side library.</li></ul>

<p>Revealing multiple keys at once is supported, and so is proving absence of a key.</p>
<p>By ordering the entries by the <em>hash</em> of the key, and branching the tree
based on the bits of that hash (i.e. a patricia trie), the merkle tree and thus the root
hash is unique for a given tree. This in particular means that insertions are efficient,
and that the tree can be reconstructed from the data, independently of the insertion order.</p>
<p>A functional API is provided (instead of an object-oriented one), so that
the actual tree can easily be stored in stable memory.</p>
<p>The tree-related functions are still limited, only insertion so far, no
lookup, deletion, modification, or more fancy operations. These can be added
when needed.</p>
<div class="declaration"><h4 class="type-declaration" id="type.Key"><span class="keyword">type </span><span class="type">Key</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Value"><span class="keyword">type </span><span class="type">Value</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Tree"><span class="keyword">type </span><span class="type">Tree</span> = <a href="#type.InternalT"><span class="type">InternalT</span></a></h4><p><p>This is the main type of this module: a possibly empty tree that maps
<code>Key</code>s to <code>Value</code>s.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Witness"><span class="keyword">type </span><span class="type">Witness</span> = {#empty; #pruned : <a href="#type.Hash"><span class="type">Hash</span></a>; #fork : (<a href="#type.Witness"><span class="type">Witness</span></a>, <a href="#type.Witness"><span class="type">Witness</span></a>); #labeled : (<a href="#type.Key"><span class="type">Key</span></a>, <a href="#type.Witness"><span class="type">Witness</span></a>); #leaf : <a href="#type.Value"><span class="type">Value</span></a>}</h4><p><p>The type of witnesses. This correponds to the <code>HashTree</code> in the Interface
Specification of the Internet Computer</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Hash"><span class="keyword">type </span><span class="type">Hash</span> = <span class="type">Blob</span></h4><p></p></div><div class="declaration"><h4 class="function" id="treeHash"><code><span class="keyword">public func </span><span class="fnname">treeHash</span>(<span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>) : <a href="#type.Hash"><span class="type">Hash</span></a></code></h4><p><p>The root hash of the merkle tree. This is the value that you would sign
or pass to <code>CertifiedData.set</code></p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>() : <a href="#type.Tree"><span class="type">Tree</span></a></code></h4><p><p>Tree construction: The empty tree</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>(<br/>  <span class="parameter">t</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <br/>  <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>, <br/>  <span class="parameter">v</span> : <a href="#type.Value"><span class="type">Value</span></a><br/>) : <a href="#type.Tree"><span class="type">Tree</span></a></code></h4><p><p>Tree construction: Inserting a key into the tree. An existing value under that key is overridden.</p>
</p></div><div class="declaration"><h4 class="function" id="reveal"><code><span class="keyword">public func </span><span class="fnname">reveal</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <span class="parameter">k</span> : <a href="#type.Key"><span class="type">Key</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Create a witness that reveals the value of the key <code>k</code> in the tree <code>tree</code>.</p>
<p>If <code>k</code> is not in the tree, the witness will prove that fact.</p>
</p></div><div class="declaration"><h4 class="function" id="merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>(<span class="parameter">w1</span> : <a href="#type.Witness"><span class="type">Witness</span></a>, <span class="parameter">w2</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Merges two witnesses, to reveal multiple values.</p>
<p>The two witnesses must come from the same tree, else this function is
undefined (and may trap).</p>
</p></div><div class="declaration"><h4 class="function" id="revealNothing"><code><span class="keyword">public func </span><span class="fnname">revealNothing</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Reveal nothing from the tree. Mostly useful as a netural element to <code>merge</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="reveals"><code><span class="keyword">public func </span><span class="fnname">reveals</span>(<span class="parameter">tree</span> : <a href="#type.Tree"><span class="type">Tree</span></a>, <span class="parameter">ks</span> : <span class="type">Iter.Iter</span>&lt;<a href="#type.Key"><span class="type">Key</span></a>&gt;) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Reveals multiple keys</p>
</p></div><div class="declaration"><h4 class="function" id="witnessUnderLabel"><code><span class="keyword">public func </span><span class="fnname">witnessUnderLabel</span>(<span class="parameter">l</span> : <span class="type">Blob</span>, <span class="parameter">w</span> : <a href="#type.Witness"><span class="type">Witness</span></a>) : <a href="#type.Witness"><span class="type">Witness</span></a></code></h4><p><p>Nests a witness under a label. This can be used when you want to use this
library (which only produces flat labeled tree), but want to be forward
compatible to a world where you actually produce nested labeled trees, or
to be compatibe with an external specification that requires you to put
this hash-of-blob-labeled tree in a subtree.</p>
<p>To not pass the result of this function to <code>merge</code>! of this ru</p>
</p></div><div class="declaration"><h4 class="function" id="hashUnderLabel"><code><span class="keyword">public func </span><span class="fnname">hashUnderLabel</span>(<span class="parameter">l</span> : <span class="type">Blob</span>, <span class="parameter">h</span> : <a href="#type.Hash"><span class="type">Hash</span></a>) : <a href="#type.Hash"><span class="type">Hash</span></a></code></h4><p><p>This goes along <code>witnessUnderLabel</code>, and transforms the hash
that is calculated by <code>treeHash</code> accordingly.</p>
<p>If you wrap your witnesses using <code>witnessUnderLabel</code> before
sending them out, make sure to wrap your tree hash with <code>hashUnderLabel</code>
before passing them to <code>CertifiedData.set</code>.</p>
</p></div></div></body></html>